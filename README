IMPARTIAL provides partial trace and partial transposition procedures for
Kronecker-product structured matrices, such as those representing states of 
multi-partite discrete variable quantum systems.

Installation

  As of release 0.3.0 it is possible to retrieve the latest release of the
  package from PyPi by running 'pip install --user impartial'

Examples

  See the examples directory.

Documentation

  - ptrace (matrix, component_dims, component_mask)

    Computes the partial trace of a Kronecker-product structured matrix.
    
    : matrix 
      defines the matrix to be partially traced

    : component_dims
      defines a list of component dimensions

    : component_mask
      defines a mask specifying whether a component should be 
      traced out (1, True) or kept (0, False).

  - ptranspose (matrix, component_dims, component_mask)

    Computes the partial transpose of a Kronecker-product structured matrix.

    : matrix 
      defines the matrix to be partially transposed

    : component_dims
      defines a list of component dimensions

    : component_mask
      defines a mask specifying whether a component should be 
      transposed (1, True) or left unaltered (0, False).

  - mask_from_index_list (index_list, system_size, inverse = False)

    A helper function, creates a component_mask from a index_list of components
    that should be left unaffected by ptrace and ptranspose operations. With
    inverse set to True the procedure interprets index_list as a list of
    components that should be affected.

    : index_list
      defines a list of component indices 

    : system_size
      defines the total number of components

    : inverse
      defines how index_list is interpreted

Operating principles of Kronecker-product and tensor representation

  Understanding the internal memory layout of the Kronecker-product structured
  matrix is fundamental for both the partial trace and partial transposition
  operations. Both algorithms begin with appropriate reshaping of the matrix
  into its tensor form. 
  
  Consider a tensor product of three matrix spaces, the first one a space of (m
  x m) dimensional matrices, the second one a space of (n x n) dimensional
  matrices and the third one a space of (o x o) dimensional matrices. Matrices
  from the product space (mno x mno) dimensional. 

  Let C be a matrix from this product space. Its tensor representation,
  can be obtained through

                    tensor = matrix.reshape([ m, n, o, m, n, o ])

  where the first three axes each correspond to the 1st axis of matrices from
  the constituent spaces. The last three axes each correspond to the 2nd axis
  of these matrices. 

  For example, should one have three matrices - A, B and C - and their 
  kronecker product, kron(kron(A, B), C), the matrix element 

                            tensor[:, 0, 2, :, 1, 3 ]

  of its tensor representation would give

                             A * B[0, 1], * C[2, 3].


Operating principles of partial transposition

  Consider an arbitrary bipartite quantum state, 

               rho = sum(i, j, k, l) r(i, j, k, l) |i><j| |k><l|.

  We define the partial transposition in respect to the second system as

             pt(rho) = sum(i, j, k, l) r(i, j, k, l) |i><j| |l><k|
                     = sum(i, j, k, l) r(i, j, l, k) |i><j| |k><l|.

  In Kronecker representation the density operator is encoded in a matrix
  rather than the rank four tensor r(i, j, k l). The partial transposition 
  is not as straightforward in this representation.

  One of the possible approaches is to determine the affected indices of the
  Kronecker matrix. Not only is this cumbersome, it is also inelegant.

  A better alternative is to reshape the matrix into tensor form of appropriate
  rank. The reshaping operation only changes the interpretation of the
  underlying memory.

  Suppose R is the Kronecker representation of the state rho. Suppose (m, n)
  are the dimensions of the individual systems comprising the state. With

                         q = reshape(R, [ m, n, m, n ])

  we obtain a rank four tensor q. But alas the tensor q is not the same as
  the tensor r(i, j, k, l). The order of their indices is different! We have

                                 q(i, k, j, l)

  instead of the original r(i, j, k, l). Consequently the partial transposition
  corresponds to exchange of the 2nd and 4th index,

                             pt(q) = q(i, l, j, k).

  We can reconstruct the Kronecker representation by reshaping the tensor back
  into the original matrix shape.

  This idea can be generalized to arbitrary amount of components. It is
  practical to use the standard numpy.transpose procedure and supply the
  correct axial permutation. Our ptranspose does exactly that.

Operating principles of partial trace
  
  We build on the same idea for partial traces and then add a figurative cherry
  on top: by reordering the tensor we can trace out everything in a single go.

  Let us begin with a bipartite system again with density matrix

               rho = sum(i, j, k, l) r(i, j, k, l) |i><j| |k><l|.

  We define the partial trace performed over the second system as

         rho' = sum(u) sum(i, j, k, l) r(i, j, k, l) |i><j| <u|k> <l|u>
              = sum(i, j, k) r(i, j, k, k) |i><j|
              = sum(i, j) [ sum(k) r(i, j, k, k) ] |i><j|

  where we have presumed orthogonality of individual { |k>, |l> } kets.

  In Kronecker representation the density operator is encoded in a matrix
  rather than the rank four tensor r(i, j, k l). We have already established 
  that the matrix R, corresponding to rho in Kronecker representation, can be
  reshaped into tensor form with different order of indices,

                                 q(i, k, j, l)

  which means that to obtain the partial trace, we must evaluate

                         g(i, j) = sum(k) q(i, k, j, k)

  which defines the (i, j) elements of the marginal matrix. This approach can
  be extended for multi-partite systems and further optimized. We can permute
  the axes to gather the parts to be traced out into a single block and then
  compute the trace in one go.

Notes and acknowledgements

  This project was inspired by QuTiP (https://github.com/qutip/qutip) and their
  essentially identical implementation. This project aims to explain the
  underlying principles behind these functions.

