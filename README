IMPARTIAL provides partial trace and partial transposition for Kronecker
representation of multi-partite discrete variable quantum systems.

Installation

  As of release 0.3.0 it is possible to retrieve the latest release of the
  package from PyPi by running 'pip install --user impartial'

Notes and acknowledgements

  This project was inspired by QuTiP (https://github.com/qutip/qutip) and their
  essentially identical implementation. This project aims to explain the
  underlying principles behind these functions.

Operating principles (Kronecker-product representation)

  Understanding the internal memory layout of the Kronecker-product structured
  matrix is fundamental for both the partial trace and partial transposition
  operations. Both algorithms begin with appropriate reshaping of the matrix
  into its tensor form. 
  
  Consider a tensor product of three matrix spaces, the first one a space of (m
  x m) dimensional matrices, the second one a space of (n x n) dimensional
  matrices and the third one a space of (o x o) dimensional matrices. Matrices
  from the product space (mno x mno) dimensional. 

  Let C be a matrix from this product space. Its tensor representation,
  can be obtained through

                    tensor = matrix.reshape([ m, n, o, m, n, o ])

  where the first three axes each correspond to the 1st axis of matrices from
  the constituent spaces. The last three axes each correspond to the 2nd axis
  of these matrices. 

  For example, should one have three matrices - A, B and C - and their 
  kronecker product, kron(kron(A, B), C), the element 

                            tensor[:, 0, 2, :, 1, 3 ]

  of its tensor representation would give the

                             A * B[0, 1], * C[2, 3]

  matrix.

Operating principles (partial transposition)

  Consider an arbitrary bipartite quantum state, 

               rho = sum(i, j, k, l) r(i, j, k, l) |i><j| |k><l|.

  We define the partial transposition in respect to the second system as

             pt(rho) = sum(i, j, k, l) r(i, j, k, l) |i><j| |l><k|
                     = sum(i, j, k, l) r(i, j, l, k) |i><j| |k><l|.

  In Kronecker representation the density operator is encoded in a matrix
  rather than the rank four tensor r(i, j, k l). The partial transposition 
  is not as straightforward in this representation.

  One of the possible approaches is to determine the affected indices of the
  Kronecker matrix. Not only is this cumbersome, it is also inelegant.

  A better alternative is to reshape the matrix into tensor form of appropriate
  rank. The reshaping operation only changes the interpretation of the
  underlying memory.

  Suppose R is the Kronecker representation of the state rho. Suppose (m, n)
  are the dimensions of the individual systems comprising the state. With

                         q = reshape(R, [ m, n, m, n ])

  we obtain a rank four tensor q. But alas the tensor q is not the same as
  the tensor r(i, j, k, l). The order of their indices is different! We have

                                 q(i, k, j, l)

  instead of the original r(i, j, k, l). Consequently the partial transposition
  corresponds to exchange of the 2nd and 4th index,

                             pt(q) = q(i, l, j, k).

  We can reconstruct the Kronecker representation by reshaping the tensor back
  into the original matrix shape.

  This idea can be generalized to arbitrary amount of components. It is
  practical to use the standard numpy.transpose procedure and supply the
  correct axial permutation. Our ptranspose does exactly that.

Operating principles (partial trace)
  
  We build on the same idea for partial traces and then add a figurative cherry
  on top: by reordering the tensor we can trace out everything in a single go.

  Let us begin with a bipartite system again with density matrix

               rho = sum(i, j, k, l) r(i, j, k, l) |i><j| |k><l|.

  We define the partial trace performed over the second system as

         rho' = sum(u) sum(i, j, k, l) r(i, j, k, l) |i><j| <u|k> <l|u>
              = sum(i, j, k) r(i, j, k, k) |i><j|
              = sum(i, j) [ sum(k) r(i, j, k, k) ] |i><j|

  where we have presumed orthogonality of individual { |k>, |l> } kets.

  In Kronecker representation the density operator is encoded in a matrix
  rather than the rank four tensor r(i, j, k l). We have already established 
  that the matrix R, corresponding to rho in Kronecker representation, can be
  reshaped into tensor form with different order of indices,

                                 q(i, k, j, l)

  which means that to obtain the partial trace, we must evaluate

                         g(i, j) = sum(k) q(i, k, j, k)

  which defines the (i, j) elements of the marginal matrix. This approach can
  be extended for multi-partite systems and further optimized. We can permute
  the axes to gather the parts to be traced out into a single block and then
  compute the trace in one go.

Documentation

  The documentation is left as an exercise to the reader. 

Examples

  Partial trace is demonstrated in examples/ptrace.
  Partial transposition is demonstrated in examples/ptranspose.

Tutorial

  Currently the module exports three functions, ptrace, ptranspose and utility
  function mask_from_carry. The primary functions, ptrace and ptranspose,
  expect three arguments,

  (1) the matrix (in Kronecker form) to be transformed
  (2) the list of dimensions of individual part of the system
  (3) the mask specifying which parts should be affected by the transformation.

  We set 0 for parts which should remain unchanged and 1 for those which should
  be partially transposed or traced out.

  The utility function, mask_from_carry, can be used to construct the mask from

  (1) the list of parts that should remain unchanged
  (2) the number of parts comprising the system.


