IMPARTIAL provides partial trace and partial transpose procedures for
matrices with Kronecker product structure. 

Installation

  As of release 0.3.0 it is possible to retrieve the latest release of the
  package from PyPi by running 'pip install --user impartial'

Examples

  See the examples directory.

Documentation

  - ptrace (matrix, component_dims, component_mask)

    Computes the partial trace of matrix with Kronecker product structure.
    
    : matrix 
      defines the matrix to be partially traced

    : component_dims
      defines a list of component dimensions

    : component_mask
      defines a mask specifying whether a component should be 
      traced out (1, True) or kept (0, False).

    Example

      Consider a density matrix R of a three qubit quantum state. A partial
      trace with respect to the 1st and 3rd qubit is obtained with 

        ptrace(R, [ 2, 2, 2 ], [ 1, 0, 1 ])

      where the mask [ 1, 0, 1 ] sets 1 for components that will be traced out.

  - ptranspose (matrix, component_dims, component_mask)

    Computes the partial transpose of a Kronecker-product structured matrix.

    : matrix 
      defines the matrix to be partially transposed

    : component_dims
      defines a list of component dimensions

    : component_mask
      defines a mask specifying whether a component should be 
      transposed (1, True) or left unaltered (0, False).

    Example

      Consider a density matrix R of a three qubit quantum state. A partial
      transposition with respect to the 1st and 3rd qubit is obtained with

        ptranspose(R, [ 2, 2, 2 ], [ 1, 0, 1 ])

      where the mask [ 1, 0, 1 ] sets 1 for components that will be transposed.

  - mask_from_component_list (component_list, mask_width, invert = False)

    A helper function which can be used to construct a component_mask from a
    list of component indices. By default 1 set for components listed in
    index_list and 0 for those unlisted. 

    This logic can be inverted by setting invert = True. The resulting mask
    will have 0 is set for listed components and 1 for those unlisted.

    : component_list
      defines a list of component indices (starting from 0)

    : mask_width
      defines the total number of components (mask width)

    : invert
      defines how component_list is translated into component_mask

    Example

      Consider a system with 5 components. Suppose the partial operation of
      choice is performed with respect to the 2nd and 4th component. The
      corresponding mask [ 0, 1, 0, 1, 0 ] can be constructed with

        mask_from_component_list([ 1, 3 ], 5)

      where we note that the indices start from 0.

      Suppose that the partial operation should NOT affect the 3rd and the 5th
      component. The respective mask [ 1, 1, 0, 1, 0 ] can be constructed with

        mask_from_component_list([ 2, 4 ], 5, invert = True)

      where setting the optional parameter (invert = True) inverts the mask.

Operating principles of Kronecker product and tensor representation

  Understanding the internal memory layout of the Kronecker-structured
  matrix is fundamental for both the partial trace and partial transposition
  operations. Both algorithms begin with appropriate reshaping of the matrix
  into its tensor form. 
  
  Consider a tensor product of three matrix spaces. Let the first one be a
  space of (m x m) dimensional matrices, the second one a space of (n x n)
  dimensional matrices and finally the third one a space of (o x o) dimensional
  matrices. The product space contains (mno x mno) dimensional matrices.

  Let R be a Kronecker-product structured matrix from this product space. Its
  tensor representation, can be obtained through

                    T = R.reshape([ m, n, o, m, n, o ])

  where the first three axes each correspond to the 1st axis of matrices from
  the constituent spaces. The last three axes each correspond to the 2nd axis
  of these matrices. 

  For example, should one have three matrices - A, B and C - and their 
  Kronecker product, kron(kron(A, B), C), the matrix element 

                            T[:, 0, 2, :, 1, 3 ]

  of its tensor representation would give

                             A * B[0, 1], * C[2, 3].

Operating principles of partial transposition

  Consider an arbitrary bipartite quantum state, 

               rho = sum(i, j, k, l) r(i, j, k, l) |i><j| |k><l|.

  We define the partial transposition with respect to the second system as

             pt(rho) = sum(i, j, k, l) r(i, j, k, l) |i><j| |l><k|
                     = sum(i, j, k, l) r(i, j, l, k) |i><j| |k><l|.

  In Kronecker representation the density operator is encoded in a matrix
  rather than the rank four tensor r(i, j, k, l). The partial transposition 
  is determined as easily in this representation.

  One of the possible approaches is to determine the affected indices of the
  Kronecker matrix. Not only is this cumbersome, it is also inelegant.

  A better alternative is to reshape the matrix into tensor form of appropriate
  rank. The reshaping operation only changes the interpretation of the
  underlying memory.

  Suppose R is the Kronecker representation of the state rho. Suppose (m, n)
  are the dimensions of the individual systems comprising the state. With

                         T = reshape(R, [ m, n, m, n ])

  we obtain a rank four tensor T. But alas the tensor T is not the same as
  the tensor r(i, j, k, l). The order of their indices is different! We have

                                 T(i, k, j, l)

  instead of the original r(i, j, k, l). Consequently the partial transposition
  corresponds to the exchange of the 2nd and 4th indices,

                       pt(T)(i, j, k, l) = T(i, l, j, k).

  We can reconstruct the Kronecker representation by reshaping the tensor back
  into the original matrix shape.

  This idea can be generalized to arbitrary amount of components. It is
  practical to use the standard numpy.transpose procedure and supply the
  correct axial permutation. Our ptranspose does exactly that.

Operating principles of partial trace
  
  We build on the same ideas we explored for partial transpose and then add a
  figurative cherry on top: by reordering the tensor we can trace out
  everything in a single go.

  Let us begin with a bipartite system again with density matrix

               rho = sum(i, j, k, l) r(i, j, k, l) |i><j| |k><l|.

  We define the partial trace performed over the second component as

         rho' = sum(u) sum(i, j, k, l) r(i, j, k, l) |i><j| <u|k> <l|u>
              = sum(i, j, k) r(i, j, k, k) |i><j|
              = sum(i, j) [ sum(k) r(i, j, k, k) ] |i><j|

  where we have presumed orthogonality of individual { |k>, |l> } kets.

  In Kronecker representation the density operator is encoded in a matrix
  rather than the rank four tensor r(i, j, k l). We have already established 
  that the matrix R, corresponding to rho in Kronecker representation, can be
  reshaped into tensor form with different order of indices,

                                 T(i, k, j, l)

  which means that to obtain the partial trace, we must evaluate

                         g(i, j) = sum(k) T(i, k, j, k)

  which defines elements g(i, j) of the marginal tensor. This approach can
  be extended for multi-partite systems and further optimized. We can permute
  the axes to gather the parts to be traced out into a single block and then
  compute the trace in one go.

Notes and acknowledgements

  This project was inspired by QuTiP (https://github.com/qutip/qutip) and their
  essentially identical implementation. This project aims to explain the
  underlying principles behind these functions.

